#version 450

#include "shaderSimData.h"

struct Object {
    vec3 position;
	float padding0;
    vec3 velocity;
	float padding1;
	vec3 accel;
	float padding2;
    vec4 rotation;
};

layout(binding = 0) buffer Objects {
    Object data[];
};

layout(binding = 1) readonly buffer Sorted0 {
    uint sorted[];
};

// TODO make code to send deltaTime to compute shader instead of hard coding it like an moron
const float deltaTime = 1/144.0;

int GetCell(ivec3 pos, out vec3 dt)
{
	const int side = int(CHUNK_COUNT_SIDE);
	const float size = int(WORLD_SIZE);
	dt = ivec3(0,0,0);
	if (pos.x < 0)
	{
		pos.x += side;
		dt.x = -size;
	}
	else if (pos.x >= side)
	{
		pos.x -= side;
		dt.x = size;
	}
	if (pos.y < 0)
	{
		pos.y += side;
		dt.y = -size;
	}
	else if (pos.y >= side)
	{
		pos.y -= side;
		dt.y = size;
	}
	if (pos.z < 0)
	{
		pos.z += side;
		dt.z = -size;
	}
	else if (pos.z >= side)
	{
		pos.z -= side;
		dt.z = size;
	}
	return pos.x + ((pos.z * side) + pos.y) * side;
}

layout (local_size_x = CHUNK_COUNT_SIDE, local_size_y = CHUNK_COUNT_SIDE, local_size_z = CHUNK_COUNT_SIDE_Z) in;

void main()
{
	uint index = gl_GlobalInvocationID.x + ((gl_GlobalInvocationID.z * CHUNK_COUNT_SIDE) + gl_GlobalInvocationID.y) * CHUNK_COUNT_SIDE;
	
	uint bufferOffset = MAX_OBJECTS_PER_CHUNK * index;
	uint objectCount = sorted[bufferOffset];
	
	for (uint index1 = 0; index1 < objectCount; index1++)
	{
		uint boid1 = sorted[bufferOffset + index1 + 1];
	
		vec3 globalPos = vec3(0);
		vec3 globalRot = vec3(0);
		vec3 avoidDir = vec3(0);
		uint count = 0;
		uint avoidCount = 0;
	
		for (int i = -1; i <= 1; i++)
		{
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					vec3 dt;
					int cellId = GetCell(ivec3(gl_GlobalInvocationID.xyz) + ivec3(i, j, k), dt);
		
					const uint otherOffset = MAX_OBJECTS_PER_CHUNK * cellId;
					uint otherCount = sorted[otherOffset];
					for (uint index2 = 0; index2 < otherCount; index2++)
					{
						uint boid2 = sorted[otherOffset + index2 + 1];
						if (boid1 == boid2)
							continue;
		
						vec3 delta = data[boid2].position - data[boid1].position + dt;
						float distSqr = dot(delta, delta);
						if (distSqr > BOID_DIST_MAX * BOID_DIST_MAX)
							continue;
		
						globalPos += delta;
						globalRot += data[boid2].velocity;
						count++;
		
						if (distSqr < BOID_DIST_MIN * BOID_DIST_MIN && distSqr > 0)
						{
							float dist = sqrt(distSqr);
							avoidCount++;
							avoidDir -= delta / (dist * dist * dist) * BOID_DIST_MIN * BOID_DIST_MIN * BOID_DIST_MIN;
						}
					}
				}
			}
		}
		
		if (count != 0)
		{
			data[boid1].accel = (globalPos / float(count)) * 700 + (globalRot / float(count)) * 2500;
			if (avoidCount != 0)
				data[boid1].accel += (avoidDir / float(avoidCount)) * 9000;
			data[boid1].accel *= deltaTime;
		}
		else
			data[boid1].accel = normalize(data[boid1].velocity) * deltaTime;
		//data[boid1].padding2 = float(count);
		/*
		if (mousePressed)
		{
			Vec2 d = positions[boid1] - cursorPos;
			if (d.Dot() < BOID_CURSOR_DIST * BOID_CURSOR_DIST)
			{
				float len = d.Length();
				accels[boid1] += d / (len * len) * deltaTime * 60000000;
			}
		}
		*/
	}
}
